@page "/SignUp"
@using System;
@using System.Collections.Generic;
@using System.ComponentModel.DataAnnotations;
@using System.Linq;
@using System.Text;
@using System.Text.Encodings.Web;
@using System.Threading.Tasks;
@using Microsoft.AspNetCore.Authentication;
@using Microsoft.AspNetCore.Authorization;
@using BlazorServerIdentityInterop.Areas.Identity.Data;
@using Microsoft.AspNetCore.Identity;
@using Microsoft.AspNetCore.Identity.UI.Services;
@using Microsoft.AspNetCore.Mvc;
@using Microsoft.AspNetCore.Mvc.RazorPages;
@using Microsoft.AspNetCore.WebUtilities;
@using Microsoft.Extensions.Logging;

@inject SignInManager<BlazorServerIdentityInteropUser> _signInManager;
@inject UserManager<BlazorServerIdentityInteropUser> _userManager;
@inject IEmailSender _emailSender;
@inject ILogger<SignUp> _logger;
@inject NavigationManager _navman;


<h1 class="text-center">Sign Up</h1>

<div class="row">
    <div class="col-md-4">
        <EditForm Model="Input" OnValidSubmit="@ValidSubmit" OnInvalidSubmit="@InvalidSubmit">
            <DataAnnotationsValidator />
            <ValidationSummary />
            <h4>Create a new account.</h4>
            <hr />
            <div class="form-group">
                <label>
                    Email"
                    <InputText @bind-Value="Input.Email" />
                </label>
            </div>
            <div class="form-group">
                <label>
                    Password
                    <InputText type="password" @bind-Value="Input.Password" />
                </label>
            </div>
            <div class="form-group">
                <label>
                    ConfirmPassword
                    <InputText type="password" @bind-Value="Input.ConfirmPassword" />
                </label>
            </div>
            <button type="submit" class="btn btn-primary">Sign Up</button>
        </EditForm>
    </div>
    <div class="col-md-6 col-md-offset-2">
        <section>
            <h4>Use another service to register.</h4>
            <hr />
            @{
                if ((ExternalLogins?.Count ?? 0) == 0)
                {
                    <div>
                        <p>
                            There are no external authentication services configured. See <a href="https://go.microsoft.com/fwlink/?LinkID=532715">this article</a>
                            for details on setting up this ASP.NET application to support logging in via external services.
                        </p>
                    </div>
                }
                else
                {
                    <form id="external-account" asp-page="./ExternalLogin" asp-route-returnUrl="@ReturnUrl" method="post" class="form-horizontal">
                        <div>
                            <p>
                                @foreach (var provider in ExternalLogins)
                                {
                                    <button type="submit" class="btn btn-primary" name="provider" value="@provider.Name" title="Log in using your @provider.DisplayName account">@provider.DisplayName</button>
                                }
                            </p>
                        </div>
                    </form>
                }
            }
        </section>
    </div>
</div>

@if (showConfirmation)
{
    @if (!string.IsNullOrEmpty(EmailConfirmationUrl))
    {
        <br />
        <p>
            This app does not currently have a real email sender registered, see <a href="https://aka.ms/aspaccountconf">these docs</a> for how to configure a real email sender.
            Normally this would be emailed: <a id="confirm-link" href="@EmailConfirmationUrl">Click here to confirm your account</a>
        </p>
    }
    else
    {
        <p>
            Please check your email to confirm your account.
        </p>
    }
}

@code
{

    public InputModel Input { get; set; } = new InputModel();

    public string ReturnUrl { get; set; }

    public IList<AuthenticationScheme> ExternalLogins { get; set; }

    // Is it time to show a confirmation
    public bool showConfirmation { get; set; }

    //String to hold the confirmation URL
    public string EmailConfirmationUrl { get; set; }

    public class InputModel
    {
        [Required]
        [EmailAddress]
        [Display(Name = "Email")]
        public string Email { get; set; }

        [Required]
        [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Password)]
        [Display(Name = "Password")]
        public string Password { get; set; }

        [DataType(DataType.Password)]
        [Display(Name = "Confirm password")]
        [Compare("Password", ErrorMessage = "The password and confirmation password do not match.")]
        public string ConfirmPassword { get; set; }
    }

    //Deprecate, no longer needed.
    //public async Task OnGetAsync(string returnUrl = null)
    //{
    //    ReturnUrl = returnUrl;
    //    ExternalLogins = (await _signInManager.GetExternalAuthenticationSchemesAsync()).ToList();
    //}

    /// <summary>
    /// Technically, UserManager and SignInManager are not supported in Razor.
    /// And SignInManager.SignInAsync definitely won't work.
    /// But they seem to work the rest of the time.  Let's give them a chance
    /// </summary>
    public async void ValidSubmit()
    {
        //This section is purely about signing up the user
        var user = new BlazorServerIdentityInteropUser { UserName = Input.Email, Email = Input.Email };

        // Actually writing the user details to database
        var result = await _userManager.CreateAsync(user, Input.Password);

        // If it failed generate error and exit
        if (!result.Succeeded)
        {
            // The <EditForm> is valid, but the transaction failed for some reason.
            // This is NOT a form validation error. One common case is the user already exists, and results in a DB error.
            // Will leave it at ValidationSummary for now and work applying EditContext later.
            return;
        }

        _logger.LogInformation("User created a new account with password.");

        // Configuration is for a confirmed email before Sign In is allowed.
        // Now set about mimicking sending a confirmation email

        var code = await _userManager.GenerateEmailConfirmationTokenAsync(user);
        code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));

        var queryparams = new Dictionary<string, string>()
{
                {"userid", user.Id },
                { "code", code}
            };
        EmailConfirmationUrl = QueryHelpers.AddQueryString(_navman.BaseUri + "SignUpConfirmEmail", queryparams);
        showConfirmation = true;
    }

    public void InvalidSubmit()
    {
        return;
    }
}